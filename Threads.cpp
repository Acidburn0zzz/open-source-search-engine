#include "gb-include.h"

#include "BigFile.h"
#include "Threads.h"
#include "Errno.h"
#include "Loop.h"
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/types.h>    // getuid()/pid_t/getpid()
#include <sys/wait.h>     // waitpid()
#include "Rdb.h"          // g_mergeUrgent
#include <sched.h>        // clone()
#include "Profiler.h"
#include "Stats.h"
#include "Process.h"

#include <pthread.h>

// main process id (or thread id if using pthreads)
//static pid_t  s_pid    = (pid_t) -1;
// on 64-bit architectures pthread_t is 64 bit and pid_t is 32 bit:
static pthread_t  s_pid    = (pthread_t) -1;


// BIG PROBLEM:
// When doing pthread_join it doesn't always ensure a thread doesn't go
// zombie. It seems like when SIGIOs are generated by sigqueue() because
// of a full signal queue, threads start going zombie on me.


// PROBLEM #1: with using the "state" to identify a thread in the queue.
// Often a caller make s a disk access using a certain "state" var.
// He gets control back when cleanUp() calls t->m_callback. And he launches
// another read thread in there, which calls Threads::exit(state) before
// the original thread entry's m_isOccupied is set to false. So
// Threads::exit(state) mistakenly picks the thread entry from the former
// thread picks it has the same state as its thread!

// PROBLEM #2: technically, a thread in Threads::exit() can set its m_done
// bit then send the signal. When the Loop sig handler sees the done bit is
// set it decrements the global thread count even though the thread may
// not have actually exited yet!! I spawned like 1,000 threads this way!!!!!

// a global class extern'd in .h file
Threads g_threads;


// . call this before calling a ThreadEntry's m_startRoutine
// . allows us to set the priority of the thread
int startUp ( void *state ) ;
void *startUp2 ( void *state ) ;

static void makeCallback ( ThreadEntry *t ) ;

// is the caller a thread?
bool Threads::amThread () {
	if ( s_pid == (pthread_t)-1 ) return false;
	// gettid() is a bit newer so not in our libc32...
	// so kinda fake it. return the "thread" id, not process id.
	// Threads::amThread() should still work based on thread ids because
	// the main process has a unique thread id as well.
	return (pthread_self() != s_pid);
}


// stack must be page aligned for mprotect
#define THRPAGESIZE 8192

// how much of stack to use as guard space
#define GUARDSIZE (32*1024)

// . crashed in saving with 800k, so try 1M
// . must be multiple of THRPAGESIZE
// pthread_create() cores in calloc() if we don't make STACK_SIZE bigger:
#define STACK_SIZE ((512+256+1024) * 1024)

#if GUARDSIZE >= STACK_SIZE
#error STACKSIZE must be larger than GUARDSIZE
#endif


#define ABSOLUTE_MAX_THREAD 50

static char *s_stackAlloc = NULL;
static int32_t  s_stackAllocSize;

static char *s_stack      = NULL;
static int32_t  s_stackSize;
static char *s_stackPtrs [ ABSOLUTE_MAX_THREAD ];

static int32_t  s_next [ ABSOLUTE_MAX_THREAD ];
static int32_t  s_head ;

// returns NULL if none left
int32_t Threads::getStack ( ) {
	if ( s_head == -1 ) return -1;
	int32_t i = s_head;
	s_head = s_next [ s_head ];
	return i;
}


void Threads::returnStack ( int32_t si ) {
	if ( s_head == -1 ) { s_head = si; s_next[si] = -1; return; }
	s_next[si] = s_head;
	s_head = si;
}


void Threads::reset ( ) {
	if ( s_stackAlloc ) {
		mprotect(s_stackAlloc, s_stackAllocSize, PROT_READ|PROT_WRITE);
		mfree ( s_stackAlloc , s_stackAllocSize,
			"ThreadStack");
	}
	s_stackAlloc = NULL;
	for ( int32_t i = 0 ; i < THREAD_TYPE_MAX ; i++ )
		m_threadQueues[i].reset();
}


Threads::Threads ( ) {
	m_numQueues = 0;
	m_initialized = false;
}


void Threads::setPid ( ) {
	// set s_pid to the main process id
	// on 64bit arch pid is 32 bit and pthread_t is 64 bit
	s_pid = (pthread_t)pthread_self();
	//log(LOG_INFO,
	//    "threads: main process THREAD id = %"UINT32"",(int32_t unsigned)s_pid);
	pthread_t tid = pthread_self();
	sched_param param;
	int policy;
	// scheduling parameters of target thread
	pthread_getschedparam ( tid, &policy, &param);
}


bool Threads::init ( ) {

	if ( m_initialized ) return true;
	m_initialized = true;

	m_needsCleanup = false;

	// sanity check
	if ( sizeof(pid_t) > sizeof(pthread_t) ) { char *xx=NULL;*xx=0; }

	setPid();

#ifdef _STACK_GROWS_UP
	return log("thread: Stack growing up not supported.");
#endif

	// allow threads until disabled
	m_disabled = false;

	// . register a sleep wrapper to launch threads every 30ms
	// . somtimes a bunch of threads mark themselves as done and the
	//   cleanUp() handler sees them as all still launched so it doesn't
	//   launch any new ones

 	//if ( ! g_loop.registerSleepCallback(30,NULL,launchThreadsWrapper))
 	//	return log("thread: Failed to initialize timer callback.");

	// try running blaster with 5 threads and you'll
	// . see like a double degrade in performance for some reason!!
	// . TODO: why?
	// . well, this should be controlled g_conf.m_maxSpiderDiskThreads
	//   for niceness 1+ threads, and g_conf.m_maxPriorityDiskThreads for
	//   niceness 0 and below disk threads
	// . 100 maxThreads out at a time, 32000 can be queued
	if ( ! g_threads.registerType ( THREAD_TYPE_DISK ,100/*maxThreads*/,32000))
		return log("thread: Failed to register thread type." );

	// . these are used by Msg5 to merge what it reads from disk
	// . i raised it from 1 to 2 and got better response time from Msg10
	// . i leave one open in case one is used for doing a big merge
	//   with high niceness cuz it would hold up high priority ones!
	// . TODO: is there a better way? cancel it when UdpServer calls
	//   Threads::suspendLowPriorityThreads() ?
	// . this used to be 2 but now defaults to 10 in Parms.cpp. i found
	//   i have less short gray lines in the performance graph when i
	//   did that on trinity.
	int32_t max2 = g_conf.m_maxCpuMergeThreads;
	if ( max2 < 1 ) max2 = 1;
	if ( ! g_threads.registerType ( THREAD_TYPE_MERGE , max2,1000) )
		return log("thread: Failed to register thread type." );

	// will raising this from 1 to 2 make it faster too?
	// i raised since global specs new servers have 2 (hyperthreaded?) cpus
	int32_t max = g_conf.m_maxCpuThreads;
	if ( max < 1 ) max = 1;
	if ( ! g_threads.registerType ( THREAD_TYPE_INTERSECT,max,200) )
		return log("thread: Failed to register thread type." );

	// filter thread spawned to call popen() to filter an http reply
	if ( ! g_threads.registerType ( THREAD_TYPE_FILTER, 2/*maxThreads*/,300) )
		return log("thread: Failed to register thread type." );

	// RdbTree uses this to save itself
	if ( ! g_threads.registerType ( THREAD_TYPE_SAVETREE,1/*maxThreads*/,100) )
		return log("thread: Failed to register thread type." );

	// . File.cpp spawns a rename thread for doing renames and unlinks
	// . doing a tight merge on titldb can be ~250 unlinks
	// . MDW up from 1 to 30 max, after doing a ddump on 3000+ collections
	//   it was taking forever to go one at a time through the unlink
	//   thread queue. seemed like a 1 second space between unlinks.
	//   1/23/1014
	if ( ! g_threads.registerType ( THREAD_TYPE_UNLINK,30/*maxThreads*/,3000) )
		return log("thread: Failed to register thread type." );

	// generic multipurpose
	if ( ! g_threads.registerType (THREAD_TYPE_GENERIC,100/*maxThreads*/,100) )
		return log("thread: Failed to register thread type." );

	// not more than this outstanding
	int32_t maxThreads = 0;
	for ( int32_t i = 0 ; i < m_numQueues ; i++ )
		maxThreads += m_threadQueues[i].m_maxLaunched;

	// limit to stack we got
	if ( maxThreads > g_conf.m_max_threads )
		maxThreads = g_conf.m_max_threads;
	if ( maxThreads > ABSOLUTE_MAX_THREAD )
		maxThreads = ABSOLUTE_MAX_THREAD;

	// allocate the stack space
	s_stackAllocSize = STACK_SIZE * maxThreads + THRPAGESIZE ;
	// clear stack to help check for overwrites
	s_stackAlloc = (char *) mcalloc ( s_stackAllocSize , "ThreadStack" );
	if ( ! s_stackAlloc )
		return log("thread: Unable to allocate %"INT32" bytes for thread "
			   "stacks.", s_stackAllocSize);

	log(LOG_INIT,"thread: Using %"INT32" bytes for %"INT32" thread stacks.",
	    s_stackAllocSize,maxThreads);

	// align
	s_stack = (char *)(((uint64_t)s_stackAlloc+THRPAGESIZE-1)&~(THRPAGESIZE-1));
	// new size
	s_stackSize = s_stackAllocSize - (s_stack - s_stackAlloc);

	// protect the whole stack while not in use
	if ( mprotect ( s_stack , s_stackSize , PROT_NONE ) )
		log("thread: Call to mprotect failed: %s.",mstrerror(errno));

	// init the linked list
	for ( int32_t i = 0 ; i < g_conf.m_max_threads ; i++ ) {
		if ( i == g_conf.m_max_threads - 1 )
			s_next[i] = -1;
		else
			s_next[i] = i + 1;

		s_stackPtrs[i] = s_stack + STACK_SIZE * i;
	}
	s_head = 0;

	// don't do real time stuff for now
	return true;
}


// all types should be registered in main.cpp before any threads launch
bool Threads::registerType ( char type , int32_t maxThreads , int32_t maxEntries ) {
	// return false and set g_errno if no more room
	if ( m_numQueues >= THREAD_TYPE_MAX ) {
		g_errno = EBUFTOOSMALL;
		return log(LOG_LOGIC,"thread: registerType: Too many thread "
			   "queues");
	}

	// initialize the ThreadQueue class for this type
	if ( ! m_threadQueues[m_numQueues].init(type, maxThreads, maxEntries))
		return false;

	// we got one more queue now
	m_numQueues++;
	return true;
}



int32_t Threads::getNumWriteThreadsOut() {
	return m_threadQueues[THREAD_TYPE_DISK].getNumWriteThreadsOut();
}


// . returns false (and may set errno) if failed to launch a thread
// . returns true if thread added to queue successfully
// . may be launched instantly or later depending on # of threads in the queue
bool Threads::call(	char type, int32_t niceness, void *state,
					void (* callback    )(void *state,ThreadEntry *t) ,
					void *(* startRoutine)(void *state,ThreadEntry *t) ) {
	// debug
	//return false;

	g_errno = 0;

	// don't spawn any if disabled
	if ( m_disabled )
		return false;

	if ( ! g_conf.m_useThreads )
		return false;

	if ( type == THREAD_TYPE_DISK && !g_conf.m_useThreadsForDisk )
		return false;
	if ( type == THREAD_TYPE_MERGE && !g_conf.m_useThreadsForIndexOps )
		return false;
	if ( type == THREAD_TYPE_INTERSECT && !g_conf.m_useThreadsForIndexOps )
		return false;
	if ( type == THREAD_TYPE_FILTER && !g_conf.m_useThreadsForSystemCalls )
		return false;

	if ( ! m_initialized && ! init() )
		return log("db: Threads init failed." );

	// find the type
	int32_t i;
	for ( i = 0 ; i < m_numQueues ; i++ )
		if ( m_threadQueues[i].m_threadType == type )
			break;

	// bitch if type not added via registerType() call
	if ( i == m_numQueues ) {
		g_errno = EBADENGINEER;
		return log(LOG_LOGIC,"thread: addtoqueue: Unregistered thread type %"INT32"",(int32_t)type);
	}

	// . add to this queue
	// . returns NULL and sets g_errno on error
	ThreadEntry *t = m_threadQueues[i].addEntry(niceness,state,callback,startRoutine);
	if ( ! t )
		return log("thread: Failed to add entry to thread pool: %s.",mstrerror(g_errno));

	// . try to launch as many threads as we can
	// . this sets g_errno on error
	// . if it has an error, just ignore it, our thread is queued
 launchLoop:
	if ( m_threadQueues[i].launchThread2 ( ) )
		goto launchLoop;

	// clear g_errno
	g_errno = 0;
	// success
	return true;
}


// . called by g_loop in Loop.cpp after getting a SI_QUEUE signal that it
//   is from when a thread exited
// . we put that signal there using sigqeueue() in Threads::exit()
// . this way another thread can be launched right away
int32_t Threads::launchThreads ( ) {

	// stop launching threads if trying to exit.
	// only launch save tree threads. so if in the middle of saving
	// we allow it to complete?
	if ( g_process.m_mode == EXIT_MODE )
		return 0;

	// try launching from each queue
	int32_t numLaunched = 0;
	// try to launch DISK threads last so cpu-based threads get precedence
	for ( int32_t i = m_numQueues - 1 ; i >= 0 ; i-- ) {

		// clear g_errno
		g_errno = 0;
		// launch as many threads as we can from queue #i
		while ( m_threadQueues[i].launchThread2( ) )
			numLaunched++;
		// continue if no g_errno set
	        if ( ! g_errno ) continue;
		// otherwise bitch about it
		log("thread: Failed to launch thread: %s.",mstrerror(g_errno));
	}
	// clear g_errno
	g_errno = 0;
	return numLaunched;
}


int32_t Threads::timedCleanUp (int32_t maxTime, int32_t niceness) {

	// skip it if exiting
	if ( g_process.m_mode == EXIT_MODE )
		return 0;

	if ( ! m_needsCleanup )
		return 0;

	int64_t startTime = gettimeofdayInMillisecondsLocal();
	int64_t took = 0;

	if ( niceness >= MAX_NICENESS ) m_needsCleanup = false;

	for ( int32_t i = 0 ; i <= niceness ; i++ ) {

		for ( int32_t j = 0 ; j < m_numQueues ; j++ )
			m_threadQueues[j].timedCleanUp ( niceness );

		launchThreads();

		if ( maxTime < 0 )
			continue;

		took = startTime - gettimeofdayInMillisecondsLocal();
		if ( took <= maxTime )
			continue;

		// ok, we have to cut if short...
		m_needsCleanup = true;
		break;
	}
	return took;
}


bool Threads::isHittingFile ( BigFile *bf ) {
	return m_threadQueues[THREAD_TYPE_DISK].isHittingFile(bf);
}


// used by UdpServer to see if it should call a low priority callback
bool Threads::hasHighPriorityCpuThreads() {
	ThreadQueue *q;
	ThreadEntry *t;

	q = &g_threads.m_threadQueues[THREAD_TYPE_INTERSECT];
	t = q->m_launchedHead;

	for ( ; t ; t = t->m_nextLink )
		if ( t->m_niceness == 0 )
			return true;

	q = &g_threads.m_threadQueues[THREAD_TYPE_MERGE];
	t = q->m_launchedHead;
	for ( ; t ; t = t->m_nextLink )
		if ( t->m_niceness == 0 )
			return true;

	return false;
}


void Threads::printState() {
	int64_t now = gettimeofdayInMilliseconds();

	for ( int32_t i = 0 ; i < m_numQueues; i++ ) {
		ThreadQueue *q = &m_threadQueues[i];

		for ( int32_t j = 0 ; j < q->m_maxEntries ; j++ ) {
			ThreadEntry *t = &q->m_entries[j];

			if(!t->m_isOccupied)
				continue;

			if(t->m_isDone) {
				log(LOG_TIMING,
				    "admin: Thread -done- "
				    "nice: %"INT32" "
				    "totalTime: %"INT64" (ms) "
				    "queuedTime: %"INT64"(ms) "
				    "runTime: %"INT64"(ms) "
				    "cleanup: %"INT64"(ms) "
				    "callback:%s",
				    t->m_niceness,
				    now - t->m_queuedTime,
				    t->m_launchedTime - t->m_queuedTime,
				    t->m_exitTime - t->m_launchedTime,
				    now - t->m_exitTime,
				    g_profiler.
				    getFnName((PTRTYPE)t->m_callback));
				continue;
			}

			if(t->m_isLaunched) {
				log(LOG_TIMING,
				    "admin: Thread -launched- "
				    "nice: %"INT32" "
				    "totalTime: %"INT64"(ms) "
				    "queuedTime: %"INT64"(ms) "
				    "runTime: %"INT64"(ms) "
				    "callback:%s",
				    t->m_niceness,
				    now - t->m_queuedTime,
				    t->m_launchedTime - t->m_queuedTime,
				    now - t->m_launchedTime,
				    g_profiler.
				    getFnName((PTRTYPE)t->m_callback));
				continue;
			}

			log(LOG_TIMING,
			    "admin: Thread -queued- "
			    "nice: %"INT32" "
			    "queueTime: %"INT64"(ms) "
			    "callback:%s",
			    t->m_niceness,
			    now - t->m_queuedTime,
			    g_profiler.getFnName((PTRTYPE)t->m_callback));
		}
	}
}




///////////////////////////////////////////////////////////////////////
// Global functions :-/
///////////////////////////////////////////////////////////////////////


void checkList  ( ThreadEntry **headPtr , ThreadEntry **tailPtr ) {
	ThreadEntry *t = *headPtr;
	// another check
	if ( tailPtr && *headPtr && ! *tailPtr ) { char *xx=NULL;*xx=0; }
	if ( tailPtr && ! *headPtr && *tailPtr ) { char *xx=NULL;*xx=0; }
	if ( ! t ) return;
	// head can not have a prev
	if ( t->m_prevLink ) { char *xx=NULL;*xx=0; }
	ThreadEntry *last = NULL;
	for ( ; t ; t = t->m_nextLink ) {
		if ( t->m_prevLink != last ) { char *xx=NULL;*xx=0; }
		if ( last && last->m_nextLink != t ) { char *xx=NULL;*xx=0; }
		last = t;
	}
	if ( ! tailPtr ) return;
	t = *tailPtr;
	// tail can not have a next
	if ( t->m_nextLink ) { char *xx=NULL;*xx=0; }
	last = NULL;
	for ( ; t ; t = t->m_prevLink ) {
		if ( t->m_nextLink != last ) { char *xx=NULL;*xx=0; }
		if ( last && last->m_prevLink != t ) { char *xx=NULL;*xx=0; }
		last = t;
	}
}


// remove from a head-only linked list
void removeLink ( ThreadEntry **headPtr , ThreadEntry *t ) {
	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , NULL );

	if ( t->m_prevLink )
		t->m_prevLink->m_nextLink = t->m_nextLink;
	else
		*headPtr = t->m_nextLink;

	if ( t->m_nextLink )
		t->m_nextLink->m_prevLink = t->m_prevLink;

	t->m_nextLink = NULL;
	t->m_prevLink = NULL;

	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , NULL );
}


// MDW: verify this::::: and the one above!!!!!!!!!!!!!!!!
// @todo: BR: ^^ meh...
void removeLink2 ( ThreadEntry **headPtr ,
		   ThreadEntry **tailPtr ,
		   ThreadEntry *t ) {
	// if ( g_conf.m_logDebugThread )
	// 	logf(LOG_DEBUG,"thread: removeLink2 [t=0x%"PTRFMT"]",
	// 	     (PTRTYPE)t);
	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , tailPtr );

	if ( t->m_prevLink )
		t->m_prevLink->m_nextLink = t->m_nextLink;
	else
		*headPtr = t->m_nextLink;

	if ( t->m_nextLink )
		t->m_nextLink->m_prevLink = t->m_prevLink;
	else
		*tailPtr = t->m_prevLink;

	t->m_nextLink = NULL;
	t->m_prevLink = NULL;

	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , tailPtr );
}


// add to a head/tail linked list's tail
void addLinkToTail ( ThreadEntry **headPtr ,
		     ThreadEntry **tailPtr ,
		     ThreadEntry *t ) {
	// if ( g_conf.m_logDebugThread )
	// 	logf(LOG_DEBUG,"thread: addLinkToTail [t=0x%"PTRFMT"]",
	// 	     (PTRTYPE)t);
	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , tailPtr );

	if ( *tailPtr ) {
		(*tailPtr)->m_nextLink = t;
		t->m_nextLink = NULL;
		t->m_prevLink = *tailPtr;
		*tailPtr = t; // t is the new tail
	}
	else {
		*headPtr = t;
		*tailPtr = t;
		t->m_nextLink = NULL;
		t->m_prevLink = NULL;
	}

	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , tailPtr );
}


// add to a head/tail linked list's head
void addLinkToHead ( ThreadEntry **headPtr ,
		     ThreadEntry **tailPtr ,
		     ThreadEntry *t ) {
	// if ( g_conf.m_logDebugThread )
	// 	logf(LOG_DEBUG,"thread: addLinkToHead [t=0x%"PTRFMT"]",
	// 	     (PTRTYPE)t);
	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , tailPtr );

	if ( *headPtr ) {
		(*headPtr)->m_prevLink = t;
		t->m_prevLink = NULL;
		t->m_nextLink = *headPtr;
		*headPtr = t; // t is the new head
	}
	else {
		*headPtr = t;
		*tailPtr = t;
		t->m_nextLink = NULL;
		t->m_prevLink = NULL;
	}

	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , tailPtr );
}


// add to a head-only linked list
void addLink ( ThreadEntry **headPtr ,
	       ThreadEntry *t ) {
	// if ( g_conf.m_logDebugThread )
	// 	logf(LOG_DEBUG,"thread: addLink [t=0x%"PTRFMT"]",
	// 	     (PTRTYPE)t);
	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , NULL );

	if ( *headPtr ) {
		(*headPtr)->m_prevLink = t;
		t->m_prevLink = NULL;
		t->m_nextLink = *headPtr;
		*headPtr = t; // t is the new head
	}
	else {
		*headPtr = t;
		t->m_nextLink = NULL;
		t->m_prevLink = NULL;
	}

	if ( g_conf.m_logDebugThread )
		checkList ( headPtr , NULL );
}


void makeCallback ( ThreadEntry *t ) {

	// save it
	int32_t saved = g_niceness;

	// log it now
	if ( g_conf.m_logDebugLoop || g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: enter thread callback t=0x%"PTRFMT" "
		    //"type=%s "
		    "state=0x%"PTRFMT" "
		    "nice=%"INT32"",
		    (PTRTYPE)t,
		    //getThreadType(),
		    (PTRTYPE)t->m_state,
		    (int32_t)t->m_niceness);

	// time it?
	int64_t start = gettimeofdayInMillisecondsLocal();

	// then set it
	if ( t->m_niceness >= 1 )
		g_niceness = 1;
	else
		g_niceness = 0;

	t->m_callback ( t->m_state , t );

	// time it?
	if ( g_conf.m_maxCallbackDelay >= 0 ) {
		int64_t elapsed = gettimeofdayInMillisecondsLocal() - start;
		if ( elapsed >= g_conf.m_maxCallbackDelay )
			log("threads: Took %"INT64" ms to call "
			    "thread callback niceness=%"INT32"",
			    elapsed,(int32_t)saved);
	}

	// log it now
	if ( g_conf.m_logDebugLoop || g_conf.m_logDebugThread )
		log(LOG_DEBUG,"loop: exit thread callback t=0x%"PTRFMT" "
		    "nice=%"INT32"",
		    (PTRTYPE)t,
		    (int32_t)t->m_niceness);

	// restore global niceness
	g_niceness = saved;
}


// threads start up with cacnellation deferred until pthreads_testcancel()
// is called, but we never call that
int startUp ( void *state ) {
	// get thread entry
	ThreadEntry *t = (ThreadEntry *)state;

	// our signal set
	sigset_t set;
	sigemptyset(&set);
	// turn these off in the thread
	sigaddset   ( &set , SIGPROF );
	pthread_sigmask(SIG_BLOCK,&set,NULL);
	// . what this lwp's priority be?
	// . can range from -20 to +20
	// . the lower p, the more cpu time it gets
	// . this is really the niceness, not the priority
	// remember the tid
	//t->m_tid = pthread_self();
	// debug
	if ( g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
		    "in startup pid=%"INT64" pppid=%"INT32"",
		    (PTRTYPE)t,(int64_t)pthread_self(),(int32_t)getppid());

	// somehow, it works ok when we have this print statement delay!!!
	//fprintf(stderr,"thread pid = %"INT32"\n",(int32_t)getpid());
	// . call the startRoutine
	// . IMPORTANT: this can NEVER do non-blocking stuff
	t->m_startRoutine ( t->m_state , t );
	// pop it off
	//pthread_cleanup_pop ( 1 /*execute handler?*/ );

	// set exit time
	int64_t now = gettimeofdayInMilliseconds();
	t->m_preExitTime = now;
	t->m_exitTime    = now;
	if ( g_conf.m_logDebugThread ) {

		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
		    "done with startup pid=%"INT64"",
		    (PTRTYPE)t,(int64_t)pthread_self());
	}

	// . now mark thread as ready for removal
	// . do this BEFORE queing the signal since we're still a thread!!!
	// . cleanUp() will take care of the rest
	// . cleanUp() will call pthread_join on us!
	t->m_isDone = true;

	// let Loop.cpp's sigHandler_r call g_thread.cleanUp()
	g_threads.m_needsCleanup = true;


	g_loop.wakeupPollLoop();

	return 0;
}


// pthread_create uses this one
void *startUp2 ( void *state ) {
  startUp ( state );
  return NULL;
}



///////////////////////////////////////////////////////////////////////
// functions for ThreadQueue
///////////////////////////////////////////////////////////////////////

ThreadQueue::ThreadQueue ( ) {
	m_entries = NULL;
	m_entriesSize = 0;
}


void ThreadQueue::reset ( ) {
	if ( m_entries ) mfree ( m_entries , m_entriesSize , "Threads" );
	m_entries = NULL;
}


bool ThreadQueue::init ( char threadType, int32_t maxThreads, int32_t maxEntries ) {
	m_threadType  = threadType;
	m_launched    = 0;
	m_returned    = 0;
	m_maxLaunched = maxThreads;

	m_isLowPrioritySuspended = false;

	// alloc space for entries
	m_maxEntries  = maxEntries;
	m_entriesSize = sizeof(ThreadEntry)*m_maxEntries;
	m_entries = (ThreadEntry *)mmalloc ( m_entriesSize , "Threads" );

	if ( ! m_entries )
		return log("thread: Failed to allocate %"INT32" bytes for thread queue.", m_entriesSize);

	for ( int32_t i = 0 ; i < m_maxEntries ; i++ ) {
		m_entries[i].m_isOccupied = false;
		m_entries[i].m_isLaunched = false;
		m_entries[i].m_isDone     = true;
		m_entries[i].m_qnum       = threadType;
		m_entries[i].m_stack      = NULL;
	}

	m_emptyHead = NULL;
	m_waitHead0 = NULL;
	m_waitHead1 = NULL;
	m_waitHead2 = NULL;
//	m_waitHead3 = NULL;
	m_waitHead4 = NULL;
	m_waitHead5 = NULL;
	m_waitHead6 = NULL;

	m_waitTail0 = NULL;
	m_waitTail1 = NULL;
	m_waitTail2 = NULL;
//	m_waitTail3 = NULL;
	m_waitTail4 = NULL;
	m_waitTail5 = NULL;
	m_waitTail6 = NULL;

	m_launchedHead = NULL;

	// do not spam the log with log debug msgs even if it is on
	char debug = g_conf.m_logDebugThread;
	g_conf.m_logDebugThread = 0;

	for ( int32_t i = 0 ; i < m_maxEntries ; i++ ) {
		ThreadEntry *t = &m_entries[i];
		t->m_prevLink = NULL;
		t->m_nextLink = NULL;
		addLink ( &m_emptyHead , t );
	}

	g_conf.m_logDebugThread = debug;

	return true;
}



int32_t ThreadQueue::getNumWriteThreadsOut () {
	// only consider disk threads
	if ( m_threadType != THREAD_TYPE_DISK )
		return 0;

	int32_t n = 0;
	for ( int32_t i = 0 ; i < m_maxEntries ; i++ ) {
		ThreadEntry *e = &m_entries[i];
		if ( ! e->m_isOccupied )
			continue;

		if ( ! e->m_isLaunched )
			continue;

		if ( e->m_isDone )
			continue;

		FileState *fs = (FileState *)e->m_state;
		if ( ! fs )
			continue;

		if ( ! fs->m_doWrite )
			continue;

		n++;
	}
	return n;
}


// return NULL and set g_errno on error
ThreadEntry *ThreadQueue::addEntry ( int32_t   niceness,
				     void  *state,
				     void  (* callback    )(void *state, ThreadEntry *t) ,
				     void *(* startRoutine)(void *state, ThreadEntry *t) ) {

	ThreadEntry *t = m_emptyHead;

	if ( ! t ) {
		g_errno = ENOTHREADSLOTS;
		static time_t s_time  = 0;
		time_t now = getTime();
		if ( now - s_time > 5 ) {
			log("thread: Could not add thread to queue. Already have %"INT32" entries.",m_maxEntries);
			s_time = now;
		}
		return NULL;
	}

	// sanity
	if ( t->m_isOccupied ) { char *xx=NULL;*xx=0; }

	t->m_niceness     = niceness;
	t->m_state        = state;
	t->m_callback     = callback;
	t->m_startRoutine = startRoutine;
	t->m_isOccupied   = true;
	t->m_stack        = NULL;
	t->m_isDone       = false;
	t->m_isLaunched   = false;
	t->m_queuedTime   = gettimeofdayInMilliseconds();

	t->m_bestHeadPtr  = NULL;
	t->m_bestTailPtr  = NULL;

	// and when the ohcrap callback gets called and the thread
	// is cleaned up it will check the FileState readsize and
	// m_isWrite to see which launch counts to decrement, so
	// since FileState will be corrupted, we need to store
	// this info directly into the thread entry.
	if ( m_threadType == THREAD_TYPE_DISK && t->m_state ) {
		FileState *fs = (FileState *)t->m_state;
		t->m_bytesToGo = fs->m_bytesToGo;
		t->m_doWrite = fs->m_doWrite;
	}
	else {
		t->m_bytesToGo = 0;
		t->m_doWrite   = false;
	}

	// there's only two linked lists we can wait in if we are not disk
	if ( m_threadType != THREAD_TYPE_DISK ) {
		ThreadEntry **bestHeadPtr = NULL;
		ThreadEntry **bestTailPtr = NULL;
		if ( niceness <= 0 ) {
			bestHeadPtr = &m_waitHead0;
			bestTailPtr = &m_waitTail0;
		}
		// 'merge' threads from disk merge ops have niceness 1
		else if ( niceness == 1 ) {
			bestHeadPtr = &m_waitHead1;
			bestTailPtr = &m_waitTail1;
		}
		// niceness is 2? MAX_NICENESS
		else {
			bestHeadPtr = &m_waitHead2;
			bestTailPtr = &m_waitTail2;
		}
		// remove from empty list
		removeLink ( &m_emptyHead , t );
		// add to waiting list at the end
		addLinkToTail ( bestHeadPtr , bestTailPtr , t );
		// debug msg
		if ( g_conf.m_logDebugThread )
			log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
			    "queued %s thread for launch1. "
			    "niceness=%"INT32". ", (PTRTYPE)t,
			    getThreadType(), (int32_t)niceness );
		return t;
	}

	//
	// otherwise we are a disk thread, there's 7 linked lists to use
	//

	char    nice = t->m_niceness;

	// get best thread candidate from best linked list of candidates
	ThreadEntry **bestHeadPtr = NULL;
	ThreadEntry **bestTailPtr = NULL;

	// short/med/long high priority (niceness 0) disk reads in head0/1/2
	// but we can't launch one more if already at our quota.
	if ( ! bestHeadPtr && nice == 0 ) {
		bestHeadPtr = &m_waitHead0;
		bestTailPtr = &m_waitTail0;
	}

	// low priority (merge or dump) disk WRITES go in waithead4
	if ( ! bestHeadPtr && t->m_doWrite ) {
		bestHeadPtr = &m_waitHead4;
		bestTailPtr = &m_waitTail4;
	}

	// niceness 1 read threads here
	if ( ! bestHeadPtr && nice == 1 ) {
		bestHeadPtr = &m_waitHead5;
		bestTailPtr = &m_waitTail5;
	}

	// niceness 2 read threads here
	if ( ! bestHeadPtr ) {
		bestHeadPtr = &m_waitHead6;
		bestTailPtr = &m_waitTail6;
	}


	if ( g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
		    "remove from empty list, add to wait list",
		    (PTRTYPE)t);

	// remove from empty list
	removeLink ( &m_emptyHead , t );

	// sanity
	if ( m_emptyHead == t ) { char *xx=NULL;*xx=0; }

	// add to the new waiting list at the end
	addLinkToTail ( bestHeadPtr , bestTailPtr , t );

	// debug msg
	if ( g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
		    "queued %s thread for launch2. "
		    "niceness=%"INT32". ", (PTRTYPE)t,
		    getThreadType(), (int32_t)niceness );
	// success
	return t;
}


bool ThreadQueue::isHittingFile ( BigFile *bf ) {
	// loop through candidates
	for ( int32_t i = 0 ; i < m_maxEntries; i++ ) {
		// point to it
		ThreadEntry *t = &m_entries[i];

		// must be occupied to be done (sanity check)
		if ( ! t->m_isOccupied )
			continue;

		// must not be done
		if ( t->m_isDone )
			continue;

		// must be a read
		if ( t->m_startRoutine != readwriteWrapper_r )
			continue;

		// shortcut
		FileState *fs = (FileState *)t->m_state;

		// get bigfile ptr
		if ( fs->m_this == bf )
			return true;
	}
	return false;
}


// . cleans up any threads that have exited
// . their m_isDone should be set to true
// . don't process threads whose niceness is > maxNiceness
// . return true if we cleaned one up
bool ThreadQueue::timedCleanUp ( int32_t maxNiceness ) {

	// top:
	int32_t   numCallbacks = 0;
	ThreadEntry *t = m_launchedHead;
	ThreadEntry *nextLink = NULL;
	// loop through candidates
	for ( ; t ; t = nextLink ) {
		// get it here in case we remove 't' from the linked list below
		nextLink = t->m_nextLink;

		// skip if not qualified
		if ( t->m_niceness > maxNiceness )
			continue;

		// must be occupied to be done (sanity check)
		if ( ! t->m_isOccupied )
			continue;

		// skip if not launched yet
		if ( ! t->m_isLaunched )
			continue;

		// skip if not done yet
		if ( ! t->m_isDone     )
			continue;

		// if pthread_create() failed it returns the errno and we
		// needsJoin is false, so do not try to join
		// to a thread if we did not create it, lest pthread_join()
		// cores
		if ( t->m_needsJoin ) {
			// . join up with that thread
			// . damn, sometimes he can block forever on his
			//   call to sigqueue(), @todo: BR: eh??
			int64_t startTime = gettimeofdayInMillisecondsLocal();
			int64_t took;
			int32_t status =  pthread_join ( t->m_joinTid , NULL );
			took = startTime - gettimeofdayInMillisecondsLocal();
			if ( took > 50 ) {
				log("threads: pthread_join took %i ms",
				    (int)took);
			}

			if ( status != 0 ) {
				log("threads: pthread_join %"INT64" = %s (%"INT32")",
				    (int64_t)t->m_joinTid,mstrerror(status),
				    status);
			}
			// debug msg
			if ( g_conf.m_logDebugThread )
				log(LOG_DEBUG,"thread: joined1 with "
				    "t=0x%"PTRFMT" "
				    "jointid=0x%"XINT64".",
				    (PTRTYPE)t,(int64_t)t->m_joinTid);

			// re-protect this stack
			mprotect ( t->m_stack + GUARDSIZE ,
				   STACK_SIZE - GUARDSIZE,
				   PROT_NONE );
			g_threads.returnStack ( t->m_si );
			t->m_stack = NULL;

		}

		char qnum     = t->m_qnum;
		ThreadQueue *tq = &g_threads.m_threadQueues[(int)qnum];
		if ( tq != this ) { char *xx = NULL; *xx = 0; }

		// now count him as returned
		m_returned++;

		numCallbacks++;

		// not running any more
		t->m_isLaunched = false;
		// not occupied any more
		t->m_isOccupied = false;

		if ( g_conf.m_logDebugThread )
			log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
			    "remove from launched list, add to empty list",
			    (PTRTYPE)t);

		// now move it to the empty list
		removeLink ( &m_launchedHead , t );
		addLink    ( &m_emptyHead    , t );

		g_errno = 0;
		makeCallback ( t );

		// clear errno again
		g_errno = 0;

		if ( g_conf.m_logDebugThread ) {
			int64_t now = gettimeofdayInMilliseconds();
			log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] %s done1. "
			    "active=%"INT32" "
			    "time since queued = %"UINT64" ms  "
			    "time since launch = %"UINT64" ms  "
			    "time since pre-exit = %"UINT64" ms  "
			    "time since exit = %"UINT64" ms",
			    (PTRTYPE)t,
			    getThreadType() ,
			    (int32_t)(m_launched - m_returned) ,
			    (uint64_t)(now - t->m_queuedTime),
			    (uint64_t)(now - t->m_launchedTime),
			    (uint64_t)(now - t->m_preExitTime) ,
			    (uint64_t)(now - t->m_exitTime) );
		}

	}

	//since we need finer grained control in loop, we no longer collect
	//the callbacks, sort, then call them.  we now call them right away
	//that way we can break out if we start taking too long and
	//give control back to udpserver.
	return numCallbacks != 0;
}


// . returns false if no thread launched
// . returns true if thread was launched
// . sets g_errno on error
// . don't launch a low priority thread if a high priority thread is running
// . i.e. don't launch a high niceness thread if a low niceness is running
bool ThreadQueue::launchThread2 ( ) {

	// or if no stacks left, don't even try
	if ( s_head == -1 ) {
		log("thread: ThreadQueue::launchThread2: no stacks available");
		return false;
	}

	// . how many threads are active now?
	// . NOTE: not perfectly thread safe here
	// @todo: BR: ^^ eek...
	int64_t active = m_launched - m_returned ;

	// debug msg
	if ( g_conf.m_logDebugThread && m_threadType == THREAD_TYPE_DISK )
		log(LOG_DEBUG,"thread: q=%s launchThread: active=%"INT64" "
		    "max=%"INT32".",getThreadType(), active,m_maxLaunched);

	// return if the max is already launched for this thread queue
	if ( active >= m_maxLaunched ) {
		log("thread: ThreadQueue::launchThread2: THREADS MAXED OUT. active > m_maxLaunched (%"INT64">%d)", active, m_maxLaunched);
		return false;
	}

	if ( m_threadType != THREAD_TYPE_DISK ) {
		// if one thread of this type is already out, forget it
		if ( m_threadType!=THREAD_TYPE_MERGE &&
		     m_threadType!=THREAD_TYPE_INTERSECT &&
		     m_launchedHead ) {
			// @todo: BR: OK with only one of all these (FILTER, SAVETREE, UNLINK, GENERIC)?
			log("thread: ThreadQueue::launchThread2: already one of that type");
			return false;
		}
		
		// first try niceness 0 queue
		ThreadEntry **bestHeadPtr = &m_waitHead0;
		ThreadEntry **bestTailPtr = &m_waitTail0;
		// if empty, try niceness 1
		if ( ! *bestHeadPtr ) {
			bestHeadPtr = &m_waitHead1;
			bestTailPtr = &m_waitTail1;
		}
		// then niceness 2
		if ( ! *bestHeadPtr ) {
			bestHeadPtr = &m_waitHead2;
			bestTailPtr = &m_waitTail2;
		}
		// if bother empty, that was easy
		if ( ! *bestHeadPtr )
			return false;

		// do not launch a low priority merge, intersect or filter
		// thread if we/ have high priority cpu threads already going
		// on. this way a low priority spider thread will not launch
		// if a high priority cpu-based thread of any kind (right now
		// just MERGE or INTERSECT) is already running.
		if ( (*bestHeadPtr)->m_niceness > 0 &&
		     g_threads.hasHighPriorityCpuThreads ( ) )
			return false;

		// otherwise launch the next one
		// THREAD_TYPE_MERGE, INTERSECT, FILTER, UNLINK, SAVETREE
		return launchThreadForReals ( bestHeadPtr , bestTailPtr );
	}


	// get lowest niceness level of launched threads
	ThreadEntry *t = m_launchedHead;
	bool hasLowNicenessOut = false;
	int32_t spiderCount = 0;
	for ( ; t ; t = t->m_nextLink ) {
		// if he's done, skip him. maybe he hasn't been cleaned up yet
		if ( t->m_isDone ) continue;

		// is the launched thread niceness 0? (i.e. high priority)
		if ( t->m_niceness == 0 ) {
			// set a flag
			hasLowNicenessOut = true;
		}
		else {
			spiderCount++;
		}
	}


	// get best thread candidate from best linked list of candidates
	ThreadEntry **bestHeadPtr = NULL;
	ThreadEntry **bestTailPtr = NULL;
	// short/med/long high priority (niceness 0) disk reads in head0/1/2
	// but we can't launch one more if already at our quota.
	if ( ! bestHeadPtr &&  m_waitHead0   ) {
		//launchedSma0 < g_conf.m_queryMaxSmaDiskThreads ) {
		bestHeadPtr = &m_waitHead0;
		bestTailPtr = &m_waitTail0;
	}

	// if we have a niceness 0 disk read/write outstanding and we are
	// 1 or 2, do not launch! we do not want low priority disk reads
	// having to contend with high priority ones.
	// now we only do this if the 'separate disk reads' parms is true.
	if ( g_conf.m_separateDiskReads && hasLowNicenessOut && ! bestHeadPtr )
		return false;

	// do not allow too high niceness read threads out
	if ( spiderCount >= g_conf.m_spiderMaxDiskThreads )
		return false;

	// low priority (merge or dump) disk WRITES go in waithead4
	if ( ! bestHeadPtr && m_waitHead4 ) {
		bestHeadPtr = &m_waitHead4;
		bestTailPtr = &m_waitTail4;
	}

	// niceness 1. for merge reads so they superscede regular spider reads
	// niceness 1 read threads:
	if ( ! bestHeadPtr && m_waitHead5 ) {
		bestHeadPtr = &m_waitHead5;
		bestTailPtr = &m_waitTail5;
	}

	// niceness 2 read threads:
	if ( ! bestHeadPtr && m_waitHead6 ) {
		bestHeadPtr = &m_waitHead6;
		bestTailPtr = &m_waitTail6;
	}

	// if nobody waiting, return false
	if ( ! bestHeadPtr ) return false;

	// i dunno what the point of this was... so i commented it out
	//int32_t max2 = g_conf.m_queryMaxDiskThreads ;
	//if ( max2 <= 0 ) max2 = 1;
	// only do this check if we're a addlists/instersect thread queue
	//if (m_threadType == THREAD_TYPE_INTERSECT&& hiActive >= max2)return false;

	// point to entry in the best linked list to launch from
	return launchThreadForReals ( bestHeadPtr , bestTailPtr );
}


bool ThreadQueue::launchThreadForReals ( ThreadEntry **headPtr ,
					 ThreadEntry **tailPtr ) {

	ThreadEntry *t = *headPtr;

	// if descriptor was closed, just return error now, we
	// cannot try to re-open because the file might have been
	// unlinked. Sync.cpp does a THREAD_TYPE_DISK but does not pass in a valid
	// FileState ptr because it does its own saving, so check for NULLs.
	FileState *fs = (FileState *)t->m_state;
	bool allocated = false;
	if ( m_threadType == THREAD_TYPE_DISK && fs && ! fs->m_doWrite ) {
		// allocate the read buffer here!
		if ( ! fs->m_doWrite && ! fs->m_buf && fs->m_bytesToGo > 0 ) {
			int32_t need = fs->m_bytesToGo + fs->m_allocOff;
			char *p = (char *) mmalloc ( need , "ThreadReadBuf" );
			if ( p ) {
				fs->m_buf       = p + fs->m_allocOff;
				fs->m_allocBuf  = p;
				fs->m_allocSize = need;
				allocated = true;
			}
			else
				log("thread: read buf alloc failed for %"INT32" bytes.",need);
			// just let the BigFile::readWrite_r() handle the
			// error for the NULL read buf
		}

		// . otherwise, they are intact, so get the real fds
		// . we know the stored File is still around because of that
		bool doWrite = fs->m_doWrite;
		BigFile *bb = fs->m_this;
		fs->m_fd1 = bb->getfd (fs->m_filenum1,!doWrite);
		fs->m_fd2 = bb->getfd (fs->m_filenum2,!doWrite);

		// is this bad?
		if ( fs->m_fd1 < 0 )
			log("disk: fd1 is %i for %s", fs->m_fd1,bb->getFilename());
		if ( fs->m_fd2 < 0 )
			log("disk: fd2 is %i for %s.", fs->m_fd2,bb->getFilename());

		fs->m_closeCount1 = getCloseCount_r ( fs->m_fd1 );
		fs->m_closeCount2 = getCloseCount_r ( fs->m_fd2 );
	}

	// count it as launched now, before we actually launch it
	m_launched++;

	// and set the flag
	t->m_isLaunched = true;
	// . launch it
	// . this sets the pthread_t ptr for identificatoin
	// . returns false on error

 loop:
	// debug msg
	if ( g_conf.m_logDebugThread ) {
		int32_t active = m_launched - m_returned ;
		int64_t now = gettimeofdayInMilliseconds();
		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] launched %s thread. "
		    "active=%"INT32" "
		     "niceness=%"INT32". waited %"UINT64" ms in queue.",
		    (PTRTYPE)t, getThreadType(), active, t->m_niceness ,
		     now - t->m_queuedTime);
	}
	// be lazy with this since it uses a significant amount of cpu
	//if ( now == -1LL ) now = gettimeofdayInMilliseconds();
	int64_t now = gettimeofdayInMilliseconds();
	//t->m_launchedTime = g_now;
	t->m_launchedTime = now;
	// loop2:
	// spawn the thread

	// assume it does not go through
	t->m_needsJoin = false;


	// supply our own stack to make pthread_create() fast otherwise
	// it has slowness issues with mmap()
	// http://www.gossamer-threads.com/lists/linux/kernel/960227
	t->m_stackSize = STACK_SIZE;
	//t->m_stack = (char *)mmalloc ( t->m_stackSize , "Threads" );
	int32_t si = g_threads.getStack ( );
	if ( si < 0 ) {
		log(LOG_LOGIC,"thread: Unable to get stack. Bad engineer.");
		goto hadError;
	}
	t->m_si    = si;
	t->m_stack = s_stackPtrs [ si ];
	// check it's aligned
	if ( (uint64_t)(t->m_stack) & (THRPAGESIZE-1) ) {
		char *xx=NULL;*xx=0; }
	// UNprotect the whole stack so we can use it
	mprotect ( t->m_stack + GUARDSIZE , STACK_SIZE - GUARDSIZE ,
		   PROT_READ | PROT_WRITE );

	pthread_attr_t attr;
	pthread_attr_init ( &attr );
	pthread_attr_setstack ( &attr , t->m_stack , t->m_stackSize );

	if ( g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
		    "remove from wait list, add to launch list",
		    (PTRTYPE)t);

	// remove from waiting linked list, whichever one it was in
	removeLink2 ( headPtr , tailPtr , t );
	// add to 'launched' linked list
	addLink ( &m_launchedHead , t );

	// save the waiting linked list we came from in case we get cancelled
	// and we have to put it back into it
	t->m_bestHeadPtr = headPtr;
	t->m_bestTailPtr = tailPtr;

	// debug
	if ( g_conf.m_logDebugThread )
		log("threads: pthread_create: "
		    "stack=%"PTRFMT" stacksize=%"INT64""
		    , (PTRTYPE)t->m_stack
		    , (int64_t)t->m_stackSize );

	// this returns 0 on success, or the errno otherwise
	g_errno = pthread_create ( &t->m_joinTid , &attr, startUp2 , t) ;

	// we're back from pthread_create
	if ( g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: Back from clone "
		    "t=0x%"PTRFMT".",
		    (PTRTYPE)t);

	// return true on successful creation of the thread
	if ( g_errno == 0 ) {
		// good stuff, the thread needs a join now
		t->m_needsJoin = true;
		return true;
	}

	// forever loop
	if ( g_errno == EAGAIN ) {
		goto hadError;
	}

	// do again if g_errno is AGAIN
	if ( g_errno == EINTR ) {
		log("thread: Call to clone was interrupted. Trying again.");
		goto loop;
	}
 hadError:

	if ( g_errno )
		log("thread: pthread_create had error = %s",
		    mstrerror(g_errno));

	// it didn't launch, did it? dec the count.
	m_launched--;
	// re-protect this stack
	mprotect ( t->m_stack + GUARDSIZE , STACK_SIZE - GUARDSIZE, PROT_NONE );

	// return the stack
	g_threads.returnStack ( t->m_si );
	t->m_stack = NULL;

	// unset the flag
	t->m_isLaunched = false;
	// bail on other errors
	log("thread: Call to clone had error: %s.", mstrerror(g_errno));
	// correction on this error
	log("thread: Try not using so much memory. "
	    "memused now =%"INT64".",g_mem.getUsedMem());
	// free allocated buffer
	if ( allocated ) {
		mfree ( fs->m_allocBuf , fs->m_allocSize , "ThreadReadBuf" );
		fs->m_buf = NULL;
	}

	if ( g_conf.m_logDebugThread )
		log(LOG_DEBUG,"thread: [t=0x%"PTRFMT"] "
		    "remove from launched list, RE-add to wait list",
		    (PTRTYPE)t);

	// remove from launched linked list
	removeLink ( &m_launchedHead , t );
	// back into the queue waiting to launch
	addLinkToHead ( headPtr , tailPtr , t );

	// i'm not sure return value matters at this point? the thread
	// is queued and hopefully will launch at some point
	return false;
}


void ThreadQueue::print ( ) {
	// loop through candidates
	for ( int32_t i = 0 ; i < m_maxEntries ; i++ ) {
		ThreadEntry *t = &m_entries[i];
		// print it
		log(LOG_INIT,"thread: address=%"PTRFMT" "
		    "state=%"PTRFMT" "
		    "occ=%i done=%i lnch=%i",
		     (PTRTYPE)t,
		     (PTRTYPE)t->m_state , t->m_isOccupied , t->m_isDone ,
		     t->m_isLaunched );
	}
}


const char *ThreadQueue::getThreadType ( ) const {
	const char *s = "unknown";
	if ( m_threadType == THREAD_TYPE_DISK		) s = "disk";
	if ( m_threadType == THREAD_TYPE_MERGE		) s = "merge";
	if ( m_threadType == THREAD_TYPE_INTERSECT	) s = "intersectlists";
	if ( m_threadType == THREAD_TYPE_FILTER		) s = "filter";
	if ( m_threadType == THREAD_TYPE_SAVETREE	) s = "savetree";
	if ( m_threadType == THREAD_TYPE_UNLINK		) s = "unlink";
	if ( m_threadType == THREAD_TYPE_GENERIC	) s = "generic";
	return s;
}


#include "BigFile.h" // FileState class

// when a BigFile is removed, much like we remove its pages from DiskPageCache
// we also remove any unlaunched reads/writes on it from the thread queue.
void ThreadQueue::removeThreads ( BigFile *bf ) {
	// did the BigFile get hosed? that means our BigFile was
	// unlinked or closed before we got a chance to launch the
	// thread.

	removeThreads2 ( &m_waitHead0 , &m_waitTail0 , bf );
	removeThreads2 ( &m_waitHead1 , &m_waitTail1 , bf );
	removeThreads2 ( &m_waitHead2 , &m_waitTail2 , bf );
//	removeThreads2 ( &m_waitHead3 , &m_waitTail3 , bf );
	removeThreads2 ( &m_waitHead4 , &m_waitTail4 , bf );
	removeThreads2 ( &m_waitHead5 , &m_waitTail5 , bf );
	removeThreads2 ( &m_waitHead6 , &m_waitTail6 , bf );
}


void ThreadQueue::removeThreads2 ( ThreadEntry **headPtr ,
				   ThreadEntry **tailPtr ,
				   BigFile *bf ) {

	int32_t saved = g_errno;

	ThreadEntry *t = *headPtr;
	ThreadEntry *nextLink = NULL;
	for ( ; t ; t = nextLink ) {
		// do it here in case we modify the linked list below
		nextLink = t->m_nextLink;
		// get the filestate
		FileState *fs = (FileState *)t->m_state;
		// skip if NULL
		if ( ! fs )
			continue;

		// skip if not match
		if ( fs->m_this != (void *)bf )
			continue;

		// . let it finish writing if it is a write thread
		// . otherwise, if we are exiting, we could free the
		//   buffer being written and cause the thread to core...
		if ( fs->m_doWrite ) {
			log(LOG_INFO,"disk: Not removing write thread.");
			continue;
		}

		// . should we really? if we renamed the file to another,
		//   we need to recompute the offsets to read, etc.. so we
		//   should fail up to Msg5 with EFILECLOSED or something...
		// . i think we did a rename and it got the same fd, and since
		//   we did not remove the launched or done threads after the
		//   rename, we're not sure if they read from the newly renamed
		//   file or not, and our read offset was for the old file...
		// . at least set the error flag for doneWrapper()
		fs->m_errno2 = EFILECLOSED;
		// log it
		logf(LOG_INFO,"disk: Removing/flagging operation in thread "
		    "queue. fs=0x%"PTRFMT"", (PTRTYPE)fs);

		// skip if already done
		if ( t->m_isDone )
			continue;

		// skip if launched
		if ( t->m_isLaunched )
			continue;

		// note in the log it is launched
		log(LOG_INFO,"disk: Thread is launched.");
		// tell donewrapper what happened
		fs->m_errno = EFILECLOSED;
		g_errno     = EFILECLOSED;

		// remove it from the thread queue
		t->m_isDone     = true;
		t->m_isLaunched = false;
		t->m_isOccupied = false;
		// keep track
		//maxi = i;

		// remove from waiting linked list, whichever one it was in
		removeLink2 ( headPtr , tailPtr , t );
		// add to 'empty' linked list
		addLink ( &m_emptyHead , t );

		makeCallback ( t );
	}

	g_errno = saved;
}


